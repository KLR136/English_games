<script>
    // Orientation Detection
    function checkOrientation() {
        const orientationMessage = document.getElementById('orientation-message');
        const isPortrait = window.innerHeight > window.innerWidth;
        
        if (isPortrait && window.innerWidth < 768) {
            orientationMessage.classList.add('active');
        } else {
            orientationMessage.classList.remove('active');
        }
    }

    // Initial check
    checkOrientation();

    // Listen for orientation changes
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);

    // Game variables
    let currentTimer;
    let timeLeft;
    const thinkingTime = 10;
    const blueScreenTime = 5;
    let currentQuestionIndex = 0;
    let isMusicPlaying = false;
    let countdownInterval;
    let fakeAlarmTimer;

    // Hard Mode specific variables
    let isBlueScreenActive = false;
    let canAnswer = false;
    let playerScore = 0;
    let penaltyActive = false;
    let isTrickScreen = false;

    // Questions data
    let allQuestions = [];
    let usedQuestions = [];

    // DOM Elements
    const questionDisplay = document.getElementById('questionDisplay');
    const answersDisplay = document.getElementById('answersDisplay');
    const statusMessage = document.getElementById('statusMessage');
    const bipSound = document.getElementById('bipSound');
    const countdownNumber = document.getElementById('countdownNumber');
    const nextButton = document.getElementById('nextButton');
    const gameView = document.getElementById('simple-game-view');
    
    // Hard Mode DOM Elements
    const hardQuestionDisplay = document.getElementById('hardQuestionDisplay');
    const hardAnswersDisplay = document.getElementById('hardAnswersDisplay');
    const hardStatusMessage = document.getElementById('hardStatusMessage');
    const hardNextButton = document.getElementById('hardNextButton');
    const hardGameView = document.getElementById('hard-game-view');
    const penaltyMessage = document.getElementById('penaltyMessage');
    const trickMessage = document.getElementById('trickMessage');
    const gameOverView = document.getElementById('game-over-view');

    // Logo elements
    const splashLogo = document.getElementById('splashLogo');
    const menuLogo = document.getElementById('menuLogo');
    const splashTeamLogo = document.getElementById('splashTeamLogo');
    const menuTeamLogo = document.getElementById('menuTeamLogo');
    const soundOnIcon = document.getElementById('soundOnIcon');

    // Load questions from JSON
    async function loadQuestions() {
        try {
            const response = await fetch('database.json');
            const data = await response.json();
            allQuestions = data.questions;
            console.log(`Loaded ${allQuestions.length} questions from database`);
        } catch (error) {
            console.error('Error loading questions:', error);
            // Fallback to empty array if loading fails
            allQuestions = [];
        }
    }

    // Get a random question
    function getRandomQuestion() {
        if (allQuestions.length === 0) {
            console.error('No questions available');
            return null;
        }

        // If we've used all questions, reset the used list
        if (usedQuestions.length >= allQuestions.length) {
            usedQuestions = [];
        }

        // Find a question that hasn't been used recently
        let availableQuestions = allQuestions.filter(q => !usedQuestions.includes(q.id));
        
        // If all questions have been used, use any question
        if (availableQuestions.length === 0) {
            availableQuestions = allQuestions;
        }

        const randomIndex = Math.floor(Math.random() * availableQuestions.length);
        const question = availableQuestions[randomIndex];
        
        // Mark this question as used
        usedQuestions.push(question.id);
        
        return question;
    }

    // Background Music Function
    function startBackgroundMusic() {
        const backgroundMusic = document.getElementById('backgroundMusic');
        backgroundMusic.volume = 0.3;
        backgroundMusic.play().catch(e => {
            console.log("Autoplay prevented - user interaction required");
        });
    }

    // Fonction pour jouer le vrai buzzer quand l'√©cran devient bleu
    function playRealBuzzer() {
        const realBuzzer = document.getElementById('bipSound');
        realBuzzer.currentTime = 0;
        realBuzzer.play().catch(e => {
            console.log("Real buzzer error:", e);
        });
    }

    // Fonction pour jouer un faux buzzer al√©atoire
    function playRandomFakeBuzzer() {
        const fakeBuzzers = [
            document.getElementById('fakebipSound1'),
            document.getElementById('fakebipSound2'), 
            document.getElementById('fakebipSound3'),
            document.getElementById('fakebipSound4')
        ];
        
        // Choisir un buzzer al√©atoire
        const randomIndex = Math.floor(Math.random() * fakeBuzzers.length);
        const randomFakeBuzzer = fakeBuzzers[randomIndex];
        
        randomFakeBuzzer.currentTime = 0;
        randomFakeBuzzer.play().catch(e => {
            console.log("Fake buzzer error:", e);
        });
    }

    // Fonction pour choisir une couleur al√©atoire (autre que bleu et rouge)
    function getRandomTrickColor() {
        const trickColors = [
            '#FFD700', // Or
            '#32CD32', // Vert lime
            '#8A2BE2', // Violet
            '#FF69B4', // Rose
            '#00CED1', // Turquoise
            '#FF8C00', // Orange fonc√©
            '#9370DB'  // Violet moyen
        ];
        
        const randomIndex = Math.floor(Math.random() * trickColors.length);
        return trickColors[randomIndex];
    }

    // Function to play beep sound (pour le bouton dans les r√®gles)
    function playBeepSound() {
        playRealBuzzer();
    }

    // Fonction pour les fausses alarmes avec d√©lai al√©atoire
    function scheduleFakeAlarms() {
        // Arr√™ter toute alarme pr√©c√©dente
        if (fakeAlarmTimer) {
            clearTimeout(fakeAlarmTimer);
        }

        // Planifier 1-3 fausses alarmes pendant le temps de r√©flexion
        const numFakeAlarms = Math.floor(Math.random() * 3) + 1; // 1 √† 3 fausses alarmes
        
        for (let i = 0; i < numFakeAlarms; i++) {
            // D√©lai al√©atoire entre 3 et 5 secondes
            const delay = (Math.random() * 2 + 3) * 1000; // 3-5 secondes
            
            setTimeout(() => {
                if (timeLeft > blueScreenTime) { // Ne pas jouer pendant l'√©cran bleu
                    playRandomFakeBuzzer();
                }
            }, delay + (i * 2000)); // Espacer les alarmes de 2 secondes
        }
    }

    // Function to change view
    function showView(viewId) {
        document.querySelectorAll('.view').forEach(view => {
            view.classList.remove('active');
        });
        document.getElementById(viewId).classList.add('active');
    }

    // Start simple game
    function startSimpleGame() {
        showView('countdown-view');
        startCountdown();
    }

    // Start hard game
    function startHardGame() {
        showView('countdown-view');
        startCountdown('hard');
    }

    // Return to menu from game
    function returnToMenu() {
        if (confirm("Do you really want to return to the menu? Your progress will be lost.")) {
            clearInterval(currentTimer);
            if (fakeAlarmTimer) {
                clearTimeout(fakeAlarmTimer);
            }
            showView('main-menu');
        }
    }

    // Start countdown
    function startCountdown(mode = 'simple') {
        let count = 3;
        countdownNumber.textContent = count;
                    
        countdownInterval = setInterval(() => {
            count--;
            countdownNumber.textContent = count;
            
            if (count <= 0) {
                clearInterval(countdownInterval);
                if (mode === 'hard') {
                    startHardGameSession();
                } else {
                    startSimpleGameSession();
                }
            }
        }, 1000);
    }

    // Start simple game session
    function startSimpleGameSession() {
        showView('simple-game-view');
        currentQuestionIndex = 0;
        startNewQuestion();
    }

    // Start hard game session
    function startHardGameSession() {
        showView('hard-game-view');
        currentQuestionIndex = 0;
        startNewHardQuestion();
    }

    // Start a new question for simple mode
    function startNewQuestion() {
        const question = getRandomQuestion();
        
        if (!question) {
            // Fallback if no questions available
            questionDisplay.textContent = "No questions available. Please check the database.";
            answersDisplay.innerHTML = '';
            statusMessage.textContent = "Error loading questions";
            return;
        }

        // Display the question
        questionDisplay.textContent = question.text;
        
        // Display answers based on question type
        answersDisplay.innerHTML = '';
        
        if (question.type === 'mcq') {
            // Multiple choice question
            question.options.forEach((option, index) => {
                const answerElement = document.createElement('div');
                answerElement.className = 'answer-item incorrect';
                answerElement.textContent = `${String.fromCharCode(65 + index)}) ${option}`;
                answersDisplay.appendChild(answerElement);
            });
        } else {
            // Open question - show answer format hint
            const answerElement = document.createElement('div');
            answerElement.className = 'answer-item incorrect';
            answerElement.textContent = "Answer format: Open response";
            answersDisplay.appendChild(answerElement);
        }

        // Reset interface
        statusMessage.textContent = "Listen and wait.";
        statusMessage.className = 'status-message thinking';
        nextButton.style.display = 'none';
        gameView.classList.remove('blue-screen');
        gameView.classList.add('waiting');

        startTimer(question);
    }

    // Start a new question for hard mode
    function startNewHardQuestion() {
        const question = getRandomQuestion();
        
        if (!question) {
            // Fallback if no questions available
            hardQuestionDisplay.textContent = "No questions available. Please check the database.";
            hardAnswersDisplay.innerHTML = '';
            hardStatusMessage.textContent = "Error loading questions";
            return;
        }

        // Reset game state
        isBlueScreenActive = false;
        canAnswer = false;
        penaltyActive = false;
        isTrickScreen = false;
        penaltyMessage.textContent = '';
        trickMessage.textContent = '';

        // Display the question
        hardQuestionDisplay.textContent = question.text;
        
        // Display answers based on question type
        hardAnswersDisplay.innerHTML = '';
        
        if (question.type === 'mcq') {
            // Multiple choice question
            question.options.forEach((option, index) => {
                const answerElement = document.createElement('div');
                answerElement.className = 'answer-item incorrect disabled';
                answerElement.textContent = `${String.fromCharCode(65 + index)}) ${option}`;
                hardAnswersDisplay.appendChild(answerElement);
            });
        } else {
            // Open question - show answer format hint
            const answerElement = document.createElement('div');
            answerElement.className = 'answer-item incorrect disabled';
            answerElement.textContent = "Answer format: Open response";
            hardAnswersDisplay.appendChild(answerElement);
        }

        // Reset interface
        hardStatusMessage.textContent = "Listen and wait";
        hardStatusMessage.className = 'status-message thinking';
        hardNextButton.style.display = 'none';
        hardGameView.classList.remove('blue-screen');
        hardGameView.classList.remove('red-screen');
        hardGameView.classList.add('waiting');

        startHardTimer(question);
    }

    // Timer for simple mode
    function startTimer(question) {
        timeLeft = thinkingTime;

        currentTimer = setInterval(() => {
            timeLeft--;

            if (timeLeft <= 0) {
                clearInterval(currentTimer);
                timeUp(question);
            }
        }, 1000);
    }

    // Timer for hard mode
    function startHardTimer(question) {
        timeLeft = thinkingTime;

        // Planifier les fausses alarmes pour le mode difficile
        scheduleFakeAlarms();

        currentTimer = setInterval(() => {
            timeLeft--;

            if (timeLeft <= 0) {
                clearInterval(currentTimer);
                hardTimeUp(question);
            }
        }, 1000);
    }

    // Time's up for simple mode
    function timeUp(question) {
        // Show blue screen
        showBlueScreen(question);
    }

    // Time's up for hard mode
    function hardTimeUp(question) {
        // Arr√™ter les fausses alarmes
        if (fakeAlarmTimer) {
            clearTimeout(fakeAlarmTimer);
        }

        // 40% de chance d'√©cran bleu normal, 60% de chance de pi√®ge
        const isNormalScreen = Math.random() < 0.4;
        
        if (isNormalScreen) {
            // √âcran bleu normal avec vrai buzzer
            showHardBlueScreen(question);
        } else {
            // Pi√®ge : soit √©cran rouge, soit autre couleur avec faux buzzer
            const isRedTrick = Math.random() < 0.5;
            
            if (isRedTrick) {
                showRedScreen(question);
            } else {
                showColorTrickScreen(question);
            }
        }
    }

    // Show blue screen for simple mode
    function showBlueScreen(question) {
        gameView.classList.remove('waiting');
        gameView.classList.add('blue-screen');
        statusMessage.textContent = "Slap and tell!";
        statusMessage.className = 'blue-screen-message';
        
        // Jouer le vrai buzzer automatiquement
        setTimeout(() => {
            playRealBuzzer();
        }, 100);
        
        // After blueScreenTime seconds, show the answer
        setTimeout(() => {
            showCorrectAnswer(question);
        }, blueScreenTime * 1000);
    }

    // Show blue screen for hard mode
    function showHardBlueScreen(question) {
        hardGameView.classList.remove('waiting');
        hardGameView.classList.add('blue-screen');
        hardStatusMessage.textContent = "SLAP AND TELL!";
        hardStatusMessage.className = 'blue-screen-message';
        
        isBlueScreenActive = true;
        canAnswer = true;
        
        // Jouer le vrai buzzer automatiquement
        setTimeout(() => {
            playRealBuzzer();
        }, 100);
        
        // Enable answer selection for MCQ questions
        if (question.type === 'mcq') {
            const answerElements = hardAnswersDisplay.querySelectorAll('.answer-item');
            answerElements.forEach(element => {
                element.classList.remove('disabled');
                element.classList.add('selectable');
            });
        }
        
        // After blueScreenTime seconds, disable answering and show correct answer
        setTimeout(() => {
            canAnswer = false;
            isBlueScreenActive = false;
            showHardCorrectAnswer(question);
        }, blueScreenTime * 1000);
    }

    // Show red screen (trick) for hard mode
    function showRedScreen(question) {
        hardGameView.classList.remove('waiting');
        hardGameView.classList.add('red-screen');
        hardStatusMessage.textContent = "‚è∞ Time's up!";
        hardStatusMessage.className = 'red-screen-message';
        trickMessage.textContent = "‚ö†Ô∏è TRICK! Wait for the BLUE screen!";
        
        // After a shorter time, switch to blue screen
        setTimeout(() => {
            hardGameView.classList.remove('red-screen');
            hardGameView.classList.add('blue-screen');
            hardStatusMessage.className = 'blue-screen-message';
            trickMessage.textContent = "";
            
            // Enable answering on blue screen
            isBlueScreenActive = true;
            canAnswer = true;
            
            // Jouer le vrai buzzer
            playRealBuzzer();
            
            // Enable answer selection for MCQ questions
            if (question.type === 'mcq') {
                const answerElements = hardAnswersDisplay.querySelectorAll('.answer-item');
                answerElements.forEach(element => {
                    element.classList.remove('disabled');
                    element.classList.add('selectable');
                });
            }
            
            // Then show the answer after the remaining time
            setTimeout(() => {
                canAnswer = false;
                isBlueScreenActive = false;
                showHardCorrectAnswer(question);
            }, (blueScreenTime - 1.5) * 1000);
        }, 1500);
    }

    // Nouvelle fonction pour l'√©cran de pi√®ge avec couleur al√©atoire
    function showColorTrickScreen(question) {
        hardGameView.classList.remove('waiting');
        // Choisir une couleur al√©atoire
        const trickColor = getRandomTrickColor();
        
        // Appliquer la couleur √† l'√©cran
        hardGameView.style.background = trickColor;
        hardStatusMessage.textContent = "‚è∞ Time's up!";
        hardStatusMessage.className = 'red-screen-message';
        trickMessage.textContent = "‚ö†Ô∏è TRICK! Wrong color!";
        
        // Jouer un faux buzzer al√©atoire
        setTimeout(() => {
            playRandomFakeBuzzer();
        }, 100);
        
        // Apr√®s un court d√©lai, passer √† l'√©cran bleu
        setTimeout(() => {
            hardGameView.style.background = '';
            hardGameView.classList.add('blue-screen');
            hardStatusMessage.className = 'blue-screen-message';
            trickMessage.textContent = "";
            
            // Enable answering on blue screen
            isBlueScreenActive = true;
            canAnswer = true;
            
            // Jouer le vrai buzzer
            playRealBuzzer();
            
            // Enable answer selection for MCQ questions
            if (question.type === 'mcq') {
                const answerElements = hardAnswersDisplay.querySelectorAll('.answer-item');
                answerElements.forEach(element => {
                    element.classList.remove('disabled');
                    element.classList.add('selectable');
                });
            }
            
            // Then show the answer after the remaining time
            setTimeout(() => {
                canAnswer = false;
                isBlueScreenActive = false;
                showHardCorrectAnswer(question);
            }, (blueScreenTime - 1.5) * 1000);
        }, 1500);
    }

    // Show correct answer for simple mode
    function showCorrectAnswer(question) {
        // Mark the correct answer
        const answerElements = answersDisplay.querySelectorAll('.answer-item');
        
        if (question.type === 'mcq') {
            // For MCQ, highlight the correct answer
            answerElements[question.correctIndex].className = 'answer-item correct';
        } else {
            // For open questions, show the expected answer
            answerElements[0].className = 'answer-item correct';
            answerElements[0].textContent = `Correct answer: ${question.answer}`;
        }

        statusMessage.textContent = "Tap to continue.";
        statusMessage.className = 'status-message thinking';
        gameView.classList.remove('blue-screen');
        nextButton.style.display = 'block';
    }

    // Show correct answer for hard mode
    function showHardCorrectAnswer(question) {
        // Mark the correct answer
        const answerElements = hardAnswersDisplay.querySelectorAll('.answer-item');
        
        if (question.type === 'mcq') {
            // For MCQ, highlight the correct answer
            answerElements[question.correctIndex].className = 'answer-item correct';
        } else {
            // For open questions, show the expected answer
            answerElements[0].className = 'answer-item correct';
            answerElements[0].textContent = `Correct answer: ${question.answer}`;
        }

        hardStatusMessage.textContent = "Tap to continue.";
        hardStatusMessage.className = 'status-message thinking';
        hardGameView.classList.remove('blue-screen');
        hardGameView.classList.remove('red-screen');
        hardNextButton.style.display = 'block';
        penaltyMessage.textContent = "";
        trickMessage.textContent = "";
    }

    // Next question for simple mode
    function nextQuestion() {
        startNewQuestion();
    }

    // Next question for hard mode
    function nextHardQuestion() {
        startNewHardQuestion();
    }

    // Handle logo loading and splash screen
    function handleLogoLoad() {
        // Load questions first, then proceed to sound screen
        loadQuestions().then(() => {
            setTimeout(() => {
                showView('sound-on-screen');
            }, 3000);
        });
    }

    function handleLogoError() {
        splashLogo.style.display = 'none';
        document.querySelector('.splash-text').textContent = 'EL BEEPER';
        // Load questions even if logo fails
        loadQuestions().then(() => {
            setTimeout(() => {
                showView('sound-on-screen');
            }, 3000);
        });
    }

    // Set up logo event listeners
    splashLogo.onload = handleLogoLoad;
    splashLogo.onerror = handleLogoError;
    menuLogo.onerror = function() {
        menuLogo.style.display = 'none';
    };
    
    // Set up team logo event listeners
    splashTeamLogo.onerror = function() {
        splashTeamLogo.style.display = 'none';
    };
    menuTeamLogo.onerror = function() {
        menuTeamLogo.style.display = 'none';
    };

    // Set up sound on icon event listener
    soundOnIcon.onerror = function() {
        soundOnIcon.style.display = 'none';
        document.querySelector('.sound-on-title').innerHTML = 'üîä TURN YOUR SOUND ON!';
    };

    // Check if logo has already loaded
    if (splashLogo.complete) {
        handleLogoLoad();
    }
</script>